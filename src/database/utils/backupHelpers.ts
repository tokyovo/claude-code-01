import { Knex } from 'knex';
import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * Backup and restore utilities for migration safety
 */

export interface BackupOptions {
  includeData?: boolean;
  includeDrop?: boolean;
  outputPath?: string;
  schemaOnly?: boolean;
}

export interface RestoreOptions {
  backupFile: string;
  dropExisting?: boolean;
}

export class MigrationBackup {
  constructor(private knex: Knex) {}

  /**
   * Create a backup of the database schema before running migrations
   */
  async createSchemaBackup(options: BackupOptions = {}): Promise<string> {
    const {
      includeData = false,
      includeDrop = true,
      outputPath = './backups',
      schemaOnly = false,
    } = options;

    // Ensure backup directory exists
    try {
      await fs.mkdir(outputPath, { recursive: true });
    } catch (error) {
      // Directory might already exist
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupFileName = `backup_${timestamp}.sql`;
    const backupFilePath = path.join(outputPath, backupFileName);

    // Get database connection info
    const config = this.knex.client.config.connection as any;
    
    // Build pg_dump command
    const pgDumpOptions = [
      '--verbose',
      '--no-owner',
      '--no-privileges',
      '--format=plain',
      '--file=' + backupFilePath,
    ];

    if (schemaOnly || !includeData) {
      pgDumpOptions.push('--schema-only');
    }

    if (includeDrop) {
      pgDumpOptions.push('--clean');
    }

    // Add connection parameters
    pgDumpOptions.push(
      `--host=${config.host}`,
      `--port=${config.port}`,
      `--username=${config.user}`,
      `--dbname=${config.database}`
    );

    console.log(`üì¶ Creating backup: ${backupFilePath}`);
    
    // Note: In a real implementation, you would execute pg_dump here
    // For this example, we'll create a basic schema backup using Knex queries
    await this.createKnexBackup(backupFilePath, options);

    return backupFilePath;
  }

  /**
   * Create a backup using Knex queries (fallback when pg_dump is not available)
   */
  private async createKnexBackup(filePath: string, options: BackupOptions): Promise<void> {
    const lines: string[] = [];
    
    lines.push('-- Database Backup');
    lines.push(`-- Created: ${new Date().toISOString()}`);
    lines.push('-- Generated by Personal Finance Tracker Migration System');
    lines.push('');

    try {
      // Get all tables
      const tables = await this.knex.raw(`
        SELECT table_name 
        FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_type = 'BASE TABLE'
        ORDER BY table_name
      `);

      // Backup table structures
      for (const table of tables.rows) {
        const tableName = table.table_name;
        
        if (tableName === 'knex_migrations' || tableName === 'knex_migrations_lock') {
          continue; // Skip Knex internal tables
        }

        lines.push(`-- Table: ${tableName}`);
        
        // Get table definition (simplified)
        const columns = await this.knex.raw(`
          SELECT column_name, data_type, is_nullable, column_default
          FROM information_schema.columns
          WHERE table_name = ?
          ORDER BY ordinal_position
        `, [tableName]);

        lines.push(`CREATE TABLE IF NOT EXISTS ${tableName} (`);
        const columnDefs = columns.rows.map((col: any) => {
          let def = `  ${col.column_name} ${col.data_type}`;
          if (col.is_nullable === 'NO') def += ' NOT NULL';
          if (col.column_default) def += ` DEFAULT ${col.column_default}`;
          return def;
        });
        lines.push(columnDefs.join(',\n'));
        lines.push(');');
        lines.push('');

        // Backup data if requested
        if (options.includeData) {
          const data = await this.knex(tableName).select('*');
          if (data.length > 0) {
            const columns = Object.keys(data[0]);
            lines.push(`-- Data for table: ${tableName}`);
            
            for (const row of data) {
              const values = columns.map(col => {
                const value = row[col];
                if (value === null) return 'NULL';
                if (typeof value === 'string') return `'${value.replace(/'/g, "''")}'`;
                if (value instanceof Date) return `'${value.toISOString()}'`;
                return String(value);
              }).join(', ');
              
              lines.push(`INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${values});`);
            }
            lines.push('');
          }
        }
      }

      // Write to file
      await fs.writeFile(filePath, lines.join('\n'));
      console.log(`‚úÖ Backup created successfully: ${filePath}`);
      
    } catch (error) {
      console.error('‚ùå Error creating backup:', error);
      throw error;
    }
  }

  /**
   * Validate that a backup file exists and is readable
   */
  async validateBackup(backupFile: string): Promise<boolean> {
    try {
      const stats = await fs.stat(backupFile);
      return stats.isFile() && stats.size > 0;
    } catch {
      return false;
    }
  }

  /**
   * List available backup files
   */
  async listBackups(backupPath = './backups'): Promise<string[]> {
    try {
      const files = await fs.readdir(backupPath);
      return files
        .filter(file => file.endsWith('.sql') && file.startsWith('backup_'))
        .sort()
        .reverse(); // Most recent first
    } catch {
      return [];
    }
  }

  /**
   * Clean old backup files (keep only the most recent N files)
   */
  async cleanOldBackups(keepCount = 5, backupPath = './backups'): Promise<void> {
    const backups = await this.listBackups(backupPath);
    const toDelete = backups.slice(keepCount);

    for (const backup of toDelete) {
      const filePath = path.join(backupPath, backup);
      await fs.unlink(filePath);
      console.log(`üóëÔ∏è  Deleted old backup: ${backup}`);
    }
  }
}

/**
 * Migration safety wrapper that creates backups before dangerous operations
 */
export class SafeMigration {
  private backup: MigrationBackup;

  constructor(private knex: Knex) {
    this.backup = new MigrationBackup(knex);
  }

  /**
   * Run a migration operation with automatic backup
   */
  async runWithBackup<T>(
    operation: () => Promise<T>,
    operationName: string,
    backupOptions?: BackupOptions
  ): Promise<T> {
    console.log(`üîÑ Starting ${operationName}`);
    
    // Create backup before operation
    const backupFile = await this.backup.createSchemaBackup({
      schemaOnly: true,
      includeData: false,
      ...backupOptions,
    });

    try {
      // Run the operation
      const result = await operation();
      
      console.log(`‚úÖ ${operationName} completed successfully`);
      return result;
      
    } catch (error) {
      console.error(`‚ùå ${operationName} failed:`, error);
      console.log(`üì¶ Backup available at: ${backupFile}`);
      throw error;
    }
  }

  /**
   * Run migration rollback with safety checks
   */
  async safeRollback(steps = 1): Promise<void> {
    return this.runWithBackup(
      async () => {
        const [batchNo, log] = await this.knex.migrate.rollback({}, true);
        console.log(`üìä Rolled back batch ${batchNo}:`, log);
      },
      `Migration rollback (${steps} step${steps === 1 ? '' : 's'})`,
      { includeData: true }
    );
  }

  /**
   * Run migration with safety checks
   */
  async safeMigrate(): Promise<void> {
    return this.runWithBackup(
      async () => {
        const [batchNo, log] = await this.knex.migrate.latest();
        if (log.length === 0) {
          console.log('üìä No migrations to run');
        } else {
          console.log(`üìä Completed batch ${batchNo}:`, log);
        }
      },
      'Migration to latest',
      { schemaOnly: true }
    );
  }
}

// Export functions for direct use
export const createBackup = (knex: Knex, options?: BackupOptions) => {
  const backup = new MigrationBackup(knex);
  return backup.createSchemaBackup(options);
};

export const safeMigrate = (knex: Knex) => {
  const safe = new SafeMigration(knex);
  return safe.safeMigrate();
};

export const safeRollback = (knex: Knex, steps = 1) => {
  const safe = new SafeMigration(knex);
  return safe.safeRollback(steps);
};

export default {
  MigrationBackup,
  SafeMigration,
  createBackup,
  safeMigrate,
  safeRollback,
};